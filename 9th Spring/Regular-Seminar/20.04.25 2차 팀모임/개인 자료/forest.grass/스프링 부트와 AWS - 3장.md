# 3.스프링 부트에서 JPA로 데이터베이스 다뤄보자
## 진도 기록

|공부 날짜|공부한 페이지 수|
|---|---|
|2020.04.22|79p ~ 124p|

## 개요
- 웹 서비스 개발하고 운영하다 보면 피할 수 없는 문제가 데이터베이스를 다루는 일입니다.
- iBatis, MyBatis
  - 개발하는 시간보다 SQL을 다루는 시간이 더 많다.
  - 객체지향 프로그래밍을 배웠는데 왜 객체지향 프로그래밍을 못하지?
  - 테이블 모델링에만 집중하고, 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하는 개발은 분명 기형적인 형태다.
- JPA라는 자바 표준 ORM 기술을 만나보자.

## 3.1 JPA 소개
- 관계형 데이터베이스가 계속해서 웹 서비스의 중심이 되면서 모든 코드는 SQL 중심이 되어갑니다.
- 관계형 데이터베이스를 사용해야만 하는 상황에서 SQL은 피할 수 없습니다.
- 패러다임 불일치
  - 관계형 데이터베이스는 어떻게 데이터를 저장할지에 초점이 맞춰진 기술입니다.
  - 객체지향 프로그래밍 언어는 메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술입니다.
  - 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다른데, 객체를 데이터베이스에 저장하려고 하니 여러 문제가 발생합니다.
  - 이를 패러다임 불일치라고 합니다.
- 상속, 1:N 등 다양한 객체 모델링을 데이터베이스로는 구현할 수 없습니다.
- 웹 애플리케이션 개발은 점점 데이터베이스 모델링에만 집중하게 됩니다. JPA는 이런 문제점을 해결하기 위해 등장하게 됩니다.
- 서로 지향하는 바가 다른 2개 영역을 중간에서 패러다임 일치를 시켜주기 위한 기술입니다.
- 즉, 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행합니다.
- 개발자는 항상 객체지향적으로 코드를 표현할 수 있으니 더는 SQL에 종속적인 개발을 하지 않아도 됩니다.
- Spring Data JPA
  - JPA는 인터페이스로서 자바 표준명세서입니다.
  - 구현체들을 좀 더 쉽게 사용하고자 추상화시킨 Spring Data JPA라는 모듈을 이용하여 JPA 기술을 다룹니다.
  - JPA <- Hibernate <- Spring Data JPA
  - Spring Data JPA가 등장한 이유는 크게 두가지가 있습니다.
  - 구현체 교체의 용이성
    - Spring Data JPA 내부에서 구현체 매핑을 지원해주고 있다.
    - Hibernate 외에 다른 구현체로 쉽게 교체하기 위함이다.
  - 저장소 교체의 용이성
    - 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함이다.
    - MogoDB로 교체가 필요하다면 개발자는 Spring Data JPA에서 Spring Data MongoDB로 의존성만 교체하면 됩니다.
- 실무에서 JPA
  - JPA를 사용하지 못하는 가장 큰 이유로 높은 러닝 커브를 이야기합니다.
  - JPA를 잘 쓰려면 객체지향 프로그래밍과 관계형 데이터베이스를 둘 다 이해해야 합니다.
  - 그만큼 JPA를 사용해서 얻은 보상은 큽니다.
  - JPA에서는 여러 성능 이슈 해결 책들을 이미 준비해놓은 상태이기 때문에 이를 잘 활용하면 네이티브 쿼리만큼의 퍼포먼스를 낼 수 있습니다. 

## 3.2 프로젝트에 Spring Data JPA 적용하기
- Domain 패키지
  - 도메인을 담을 패키지
  - 도메인이란 게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제 영역이라고 생각하면 됩니다.
- Entity PK는 Long Type - Auto_increment로 하자
- Entity 클래스에는 절대 Setter 메서드를 만들지 않습니다. - 엔티티의 메서드를 이용하자
- @Builder - 생성자보다는 빌더패턴을 애용하자.
- Repository는 Entity와 함께 Domain 패키지에 함께 위치 시키자.

## 3.3 Spring Data JPA 테스트 코드 작성하기
<pre><code>
spring.jpa.show_sql = true //실행되는 쿼리 확인
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect //방언 설정
</code></pre>

## 3.4 등록/수정/조회 API 만들기
- Spring 웹 계층
  - Web Layer, Servie Layer, Repository Layer, Dtos, Domain Model
- 트랜잭션 스크립트
  - 기존에 서비스로 처리하던 방식(서비스에서 모든 로직 처리)
  - 서비스 계층이 무의미하며, 객체란 단순히 데이터 덩어리 역할만 하게 됩니다.
- 서비스 계층
  - 트랜잭션과 도메인 간의 순서만 보장해 줍니다.
- 3가지 Bean 주입(DI) 방법
  - 생성자 주입
  - 세터 주입
  - 필드 주입
- Entity 클래스를 Request/Response 클래스로 사용해서는 안됩니다.(DTO 사용하자)
- 영속성 컨텐스트
  - update 기능에서 데이터베이스에 쿼리를 날리는 부분이 없습니다.
  - 엔티티를 영구 저장하는 환경입니다. 일종의 논리적 개념이라고 보시면 되며, JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈립니다.
  - JPA 엔티티 매니저가 활성화된 상태로 트랜잭션 안에서 데이터베이스에서 데이터를 가져오면 이 데이터는 역속성 컨텍스트가 유지된 상태입니다.
  - 이 상태에서 해당 데이터의 값을 변경하면 트랜잭션이 끝나는 시점에 해당 테이블에 변경분을 반영합니다.
  - 즉, Entity 객체의 값만 변경하면 별도로 Update 쿼리를 날릴 필요가 없다는 것이죠. 이 개념을 더티 체킹이라고 합니다.

## 3.5 JPA Auditing으로 생성시간/수정시간 자동화하기
- 보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함합니다.
- 언제 만들어졌는지, 언제 수정되었는지 등은 차후 유지보수에 있어 굉장히 중요한 정보이기 때문입니다.
- @MappedSuperclass
  - JPA Entity 클래스들이 BaseTimeEntity을 상속할 경우 필드들도 칼럼으로 인식하도록 합니다.
- @EntityListeners
  - BaseTimeEntity 클래스에 Auditing 기능을 포함시킵니다.
- @CreatedDate
  - Entity가 생성되어 저장될 때 시간이 자동 저장됩니다.


## 궁금한 점 스스로 찾아보기
### DDD의 Layered Architecture와 Spring Web Layer가 비슷하다.
- [카카오헤어샵의 DDD](https://brunch.co.kr/@cg4jins/7)
- [DDD - Architecture](https://nesoy.github.io/articles/2018-08/DDD-Architecture)

## 회고
- Auditing을 통하여 생성시간, 수정시간을 자동화 할 수 있다는 걸 알게 되었다. 써봐야지 ㅎㅎ
- 영속성 컨텐스트가 기억이 거의 나지 않는다. 공부해야겠다...
